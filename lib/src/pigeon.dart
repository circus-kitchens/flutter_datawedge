// Autogenerated from Pigeon (v10.1.6), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// Mode for profile creations
enum ConfigMode {
  createIfNotExists,
  overwrite,
  update,
}

/// Plugin to be configured
enum PluginName {
  barcode,
  msr,
  rfid,
  serial,
  voice,
  workflow,
  bdf,
  adf,
  tokens,
  intent,
  keystroke,
  ip,
  dcp,
  ekb,
}

enum ScannerIdentifer {
  auto,
  internalImager,
  internalLaser,
  internalCamera,
  serialSSI,
  bluetoothSSI,
  bluetoothRS6000,
  bluetoothDS2278,
  bluetoothDS3678,
  plugableSsi,
  plugableSsiRS5000,
  usbSsiDS3608,
  bluetoothZebra,
  usbZebra,
}

enum UpcSupplementalMode {
  none,
  always,
  auto,
  smart,
  supplemental378to379,
  supplemental978to979,
  supplemental414to419and434to439,
  supplemental977,
}

enum UpcEanCouponReport {
  oldMode,
  newMode,
  both,
}

enum UpcEanBooklandFormat {
  isbn10,
  isbn13,
}

enum ScanningMode {
  single,
  udi,
  multiBarcode,
  documentCapture,
}

enum InverseOcr {
  regular,
  inverse,
  auto,
}

enum OcrOrientation {
  degree_0,
  degree_90,
  degree_180,
  degree_270,
  omnidirectional,
}

enum IntentDelivery {
  startActivity,
  startService,
  broadcast,
}

enum DpmMode {
  disabled,
  mode1,
  mode2,
}

enum BeamWidth {
  narrow,
  normal,
  wide,
}

enum PowerMode {
  low,
  high,
  alwaysOn,
  optimized,
}

enum MpdMode {
  display_off,
  display_on,
}

enum PicklistMode {
  disabled,
  hardware,
  software,
}

enum ReaderMode {
  triggered,
  presentation,
}

enum TriggerSource {
  left,
  right,
  center,
  gun,
  proximity,
  keyMapperScan,
  keyMapperL1,
  keyMapperR1,
  wiredLeft,
  wiredRight,
}

enum DpmIlluminationControl {
  direct,
  indirect,
  cycle,
}

enum VolumeSliderType {
  ringer,
  musicMedia,
  alarms,
  notification,
}

enum CodeIdType {
  none,
  aim,
  symbol,
}

enum ViewFinderMode {
  enabled,
  staticReticle,
}

enum Charset {
  auto,
  utf8,
  iso88591,
  shiftJis,
  gb18030,
  none,
}

enum EffortLevel {
  level_0,
  level_1,
  level_2,
  level_3,
}

enum Inverse1dMode {
  disable,
  enable,
  auto,
}

enum DelayToLowPowerMode {
  seconds_1,
  seconds_30,
  minutes_1,
  minutes_5,
}

enum LcdMode {
  disabled,
  enabled,
}

enum IlluminationMode {
  off,
  torch,
}

enum SceneDetectQualifier {
  none,
  proximitySensor,
}

enum AimType {
  trigger,
  timedHold,
  timedRelease,
  pressAndRelease,
  presentation,
  continousRead,
  pressAndSustain,
  pressAndContinue,
  timedContinous,
}

enum SwitchOnEvent {
  disabled,
  onConnect,
  onDisconnect,
  connectOrDisconnect,
}

enum PresentationModeSensitivity {
  high,
  medium,
  low,
}

enum LabelType {
  code39,
  codabar,
  code128,
  d2of5,
  iata2of5,
  i2of5,
  code93,
  upca,
  upce0,
  upce1,
  ean8,
  ean13,
  msi,
  ean128,
  trioptic39,
  bookland,
  coupon,
  databarCoupon,
  isbt128,
  code32,
  pdf417,
  micropdf,
  tlc39,
  code11,
  maxicode,
  datamatrix,
  qrcode,
  gs1Databar,
  gs1DatabarLim,
  gs1DatabarExp,
  uspostnet,
  usplanet,
  ukpostal,
  jappostal,
  auspostal,
  dutchpostal,
  finnishpostal4s,
  canpostal,
  chinese2of5,
  aztec,
  microqr,
  us4state,
  us4stateFics,
  compositeAb,
  compositeC,
  webcode,
  signature,
  korean3of5,
  matrix2of5,
  ocr,
  hanxin,
  mailmark,
  format,
  gs1Datamatrix,
  gs1Qrcode,
  dotcode,
  gridmatrix,
  undefined,
}

enum ScanSource {
  msr,
  scanner,
  simulscan,
  serial,
  voice,
  rfid,
}

enum DecodeMode {
  multiple,
  single,
}

enum ScannerState {
  waiting,
  scanning,
  idle,
  connected,
  disconnected,
  disabled,
}

enum Decoder {
  australianPostal,
  aztec,
  canadianPostal,
  chinese2of5,
  codabar,
  code11,
  code32,
  code39,
  code93,
  code128,
  compositeAb,
  compositeC,
  datamatrix,
  signature,
  d2of5,
  dotcode,
  dutchPostal,
  ean8,
  ean13,
  finnishPostal4s,
  gridMatrix,
  gs1Databar,
  gs1DatabarLim,
  gs1DatabarExp,
  gs1Datamatrix,
  gs1Qrcode,
  hanxin,
  i2of5,
  japanesePostal,
  korean3of5,
  mailmark,
  matrix2of5,
  maxicode,
  micrE13b,
  micropdf,
  microqr,
  msi,
  ocrA,
  ocrB,
  pdf417,
  qrcode,
  tlc39,
  trioptic39,
  ukPostal,
  usCurrency,
  usplanet,
  usPostal,
  uspostnet,
  upca,
  upce0,
  upce1,
  us4state,
  us4stateFics,
}

/// An application that will trigger the profile
class AppEntry {
  AppEntry({
    required this.packageName,
    required this.activityList,
  });

  String packageName;

  List<String?> activityList;

  Object encode() {
    return <Object?>[
      packageName,
      activityList,
    ];
  }

  static AppEntry decode(Object result) {
    result as List<Object?>;
    return AppEntry(
      packageName: result[0]! as String,
      activityList: (result[1] as List<Object?>?)!.cast<String?>(),
    );
  }
}

class PluginIntentParamters {
  PluginIntentParamters({
    this.intentOutputEnabled,
    this.intentAction,
    this.intentCategory,
    this.intentDelivery,
    this.intentUseContentProvider,
  });

  bool? intentOutputEnabled;

  String? intentAction;

  String? intentCategory;

  IntentDelivery? intentDelivery;

  bool? intentUseContentProvider;

  Object encode() {
    return <Object?>[
      intentOutputEnabled,
      intentAction,
      intentCategory,
      intentDelivery?.index,
      intentUseContentProvider,
    ];
  }

  static PluginIntentParamters decode(Object result) {
    result as List<Object?>;
    return PluginIntentParamters(
      intentOutputEnabled: result[0] as bool?,
      intentAction: result[1] as String?,
      intentCategory: result[2] as String?,
      intentDelivery: result[3] != null
          ? IntentDelivery.values[result[3]! as int]
          : null,
      intentUseContentProvider: result[4] as bool?,
    );
  }
}

/// Used to configure the barcode plugin. Parameters can be found here
/// https://techdocs.zebra.com/datawedge/13-0/guide/api/setconfig/
class PluginBarcodeParamters {
  PluginBarcodeParamters({
    this.decoderConfig,
    this.dataBarToUpcEan,
    this.upcEnableMarginlessDecode,
    this.upcEanSecurityLevel,
    this.upcEanSupplemental2,
    this.upcEanSupplemental5,
    this.upcEanSupplementalMode,
    this.upcEanRetryCount,
    this.upcEeanLinearDecode,
    this.upcEanBookland,
    this.upcEanCoupon,
    this.upcEanCouponReport,
    this.upcEanZeroExtend,
    this.upceanBooklandFormat,
    this.scanningMode,
    this.docCaptureTemplate,
    this.commonBarcodeDynamicQuantity,
    this.barcodeHighlightingEnabled,
    this.ruleName,
    this.enableUdiGs1,
    this.enableUdiHibcc,
    this.enableUdiIccbba,
    this.ocrOrientation,
    this.ocrLines,
    this.ocrMinChars,
    this.ocrMaxChars,
    this.ocrSubset,
    this.ocrQuietZone,
    this.ocrTemplate,
    this.ocrCheckDigitModulus,
    this.ocrCheckDigitMultiplier,
    this.ocrCheckDigitValidation,
    this.inverseOcr,
    this.presentationModeSensitivity,
    this.enableHardwareTrigger,
    this.autoSwitchToDefaultOnEvent,
    this.digimarcDecoding,
    this.multiBarcodeCount,
    this.enableInstantReporting,
    this.reportDecodedBarcodes,
    this.scannerTriggerResource,
    this.scannerInputEnabled,
    this.scannerSelection,
    this.configureAllScanners,
    this.scannerSelectionByIdentifier,
    this.enableAimMode,
    this.beamTimer,
    this.enableAdaptiveScanning,
    this.beamWidth,
    this.powerMode,
    this.mpdMode,
    this.readerMode,
    this.linearSecurityLevel,
    this.picklist,
    this.aimType,
    this.sceneDetectQualifier,
    this.aimTimer,
    this.sameBarcodeTimeout,
    this.triggerWakeupScan,
    this.differentBarcodeTimeout,
    this.illuminationMode,
    this.illuminationBrightness,
    this.lcdMode,
    this.lowPowerTimeout,
    this.delayToLowPowerMode,
    this.inverse1dMode,
    this.viewFinderSize,
    this.viewFinderPosX,
    this.viewFinderPosY,
    this.marginlessEffortLevel1d,
    this.poorQualityBcDecodeEffortLevel,
    this.charsetName,
    this.autoCharsetPrefferedOrder,
    this.autoCharsetFallback,
    this.viewFinderMode,
    this.codeIdType,
    this.volumeSliderType,
    this.decodeAudioFeedbackUri,
    this.decodeHapticFeedback,
    this.btDisconnectOnExit,
    this.connectionIdleTime,
    this.establishConnectionTime,
    this.remoteScannerAudioFeedbackMode,
    this.remoteScannerLedFeedbackMode,
    this.displayBtAddressBarcode,
    this.goodDecodeLedTimer,
    this.decodingLedFeedback,
    this.decoderUsPlanetReportCheckDigit,
    this.decodeScreenNotification,
    this.decodeScreenTime,
    this.decodeScreenTranslucency,
    this.keepParingInfoAfterReboot,
    this.dpmIlluminationControl,
    this.dpmMode,
    this.qrLaunchEnable,
    this.qrLaunchEnableQrDecoder,
    this.qrLaunchShowConfirmationDialog,
    this.noDecodeTime,
  });

  /// Configure decoders
  List<DecoderConfigItem?>? decoderConfig;

  bool? dataBarToUpcEan;

  bool? upcEnableMarginlessDecode;

  int? upcEanSecurityLevel;

  bool? upcEanSupplemental2;

  bool? upcEanSupplemental5;

  UpcSupplementalMode? upcEanSupplementalMode;

  int? upcEanRetryCount;

  bool? upcEeanLinearDecode;

  bool? upcEanBookland;

  bool? upcEanCoupon;

  UpcEanCouponReport? upcEanCouponReport;

  bool? upcEanZeroExtend;

  UpcEanBooklandFormat? upceanBooklandFormat;

  ScanningMode? scanningMode;

  String? docCaptureTemplate;

  int? commonBarcodeDynamicQuantity;

  bool? barcodeHighlightingEnabled;

  String? ruleName;

  bool? enableUdiGs1;

  bool? enableUdiHibcc;

  bool? enableUdiIccbba;

  OcrOrientation? ocrOrientation;

  /// Set number of lines to scan during OCR reading:
  int? ocrLines;

  /// Set minimum number of OCR characters (not including spaces) per line to
  /// decode during OCR reading. Integer value 3-100
  int? ocrMinChars;

  /// Set maximum number of OCR characters (not including spaces) per line to
  /// decode during OCR reading. Integer value:
  int? ocrMaxChars;

  /// Defines a custom group of characters in place of a preset font variant.
  String? ocrSubset;

  /// Set field width of blank space to stop scanning during OCR reading.
  /// The default is 50, indicating a six character width quiet zone. 20-99
  int? ocrQuietZone;

  /// Creates a template for precisely matching scanned OCR characters to a
  /// desired input format, which helps eliminate scanning errors. The template
  /// expression is formed by numbers and letters. The default is 99999999 which
  ///  accepts any alphanumeric character OCR string. If there are less than
  ///  8 '9' characters, the '9' represents only digit values.
  /// More info https://techdocs.zebra.com/datawedge/13-0/guide/input/barcode/#ocrparamsocraocrb
  String? ocrTemplate;

  /// Sets the Check Digit Modulus value for OCR Check Digit Calculation.
  int? ocrCheckDigitModulus;

  /// Sets OCR check digit multipliers for the character positions.
  int? ocrCheckDigitMultiplier;

  /// None - 0 (default)
  /// Product Add Left to Right - 3
  /// Product Add Right to Left - 1
  /// Digit Add Left to Right - 4
  /// Digit Add Right to Left - 2
  /// Product Add Right to Left Simple Remainder - 5
  /// Digit Add Right to Left Simple Remainder - 6
  /// Health Industry - HIBCC43 - 9
  int? ocrCheckDigitValidation;

  /// White or light words on black or dark background. This option is used
  /// to select normal, inverse or both OCR scanning.
  InverseOcr? inverseOcr;

  PresentationModeSensitivity? presentationModeSensitivity;

  bool? enableHardwareTrigger;

  SwitchOnEvent? autoSwitchToDefaultOnEvent;

  bool? digimarcDecoding;

  int? multiBarcodeCount;

  bool? enableInstantReporting;

  bool? reportDecodedBarcodes;

  TriggerSource? scannerTriggerResource;

  bool? scannerInputEnabled;

  ScannerIdentifer? scannerSelection;

  bool? configureAllScanners;

  String? scannerSelectionByIdentifier;

  bool? enableAimMode;

  int? beamTimer;

  bool? enableAdaptiveScanning;

  BeamWidth? beamWidth;

  PowerMode? powerMode;

  MpdMode? mpdMode;

  ReaderMode? readerMode;

  int? linearSecurityLevel;

  PicklistMode? picklist;

  AimType? aimType;

  SceneDetectQualifier? sceneDetectQualifier;

  int? aimTimer;

  int? sameBarcodeTimeout;

  bool? triggerWakeupScan;

  int? differentBarcodeTimeout;

  IlluminationMode? illuminationMode;

  int? illuminationBrightness;

  LcdMode? lcdMode;

  int? lowPowerTimeout;

  DelayToLowPowerMode? delayToLowPowerMode;

  Inverse1dMode? inverse1dMode;

  int? viewFinderSize;

  int? viewFinderPosX;

  int? viewFinderPosY;

  EffortLevel? marginlessEffortLevel1d;

  EffortLevel? poorQualityBcDecodeEffortLevel;

  Charset? charsetName;

  List<String?>? autoCharsetPrefferedOrder;

  Charset? autoCharsetFallback;

  ViewFinderMode? viewFinderMode;

  CodeIdType? codeIdType;

  VolumeSliderType? volumeSliderType;

  String? decodeAudioFeedbackUri;

  bool? decodeHapticFeedback;

  bool? btDisconnectOnExit;

  int? connectionIdleTime;

  int? establishConnectionTime;

  int? remoteScannerAudioFeedbackMode;

  int? remoteScannerLedFeedbackMode;

  bool? displayBtAddressBarcode;

  int? goodDecodeLedTimer;

  bool? decodingLedFeedback;

  bool? decoderUsPlanetReportCheckDigit;

  bool? decodeScreenNotification;

  /// / Length of time (in milliseconds) to display the screen notification
  /// upon successful decode. 500-1500
  int? decodeScreenTime;

  /// Sets the translucency value for the decode notification green screen -
  /// higher values result to more translucency.
  ///  Values range from 20 to 50 in increments of 5:
  int? decodeScreenTranslucency;

  /// Enable/disable automatic re-connection to the connected Bluetooth scanner
  ///  after device reboot. Applies only to connected Bluetooth scanners:
  bool? keepParingInfoAfterReboot;

  /// Controls the illumination for decoding DPM barcodes.
  /// Default value is cycle.
  DpmIlluminationControl? dpmIlluminationControl;

  /// Optimize DPM barcode decoding performance based on the barcode size.
  /// Default is Mode 2
  DpmMode? dpmMode;

  bool? qrLaunchEnable;

  bool? qrLaunchEnableQrDecoder;

  bool? qrLaunchShowConfirmationDialog;

  /// Integer from 0 to 180000 in 1000 increments
  int? noDecodeTime;

  Object encode() {
    return <Object?>[
      decoderConfig,
      dataBarToUpcEan,
      upcEnableMarginlessDecode,
      upcEanSecurityLevel,
      upcEanSupplemental2,
      upcEanSupplemental5,
      upcEanSupplementalMode?.index,
      upcEanRetryCount,
      upcEeanLinearDecode,
      upcEanBookland,
      upcEanCoupon,
      upcEanCouponReport?.index,
      upcEanZeroExtend,
      upceanBooklandFormat?.index,
      scanningMode?.index,
      docCaptureTemplate,
      commonBarcodeDynamicQuantity,
      barcodeHighlightingEnabled,
      ruleName,
      enableUdiGs1,
      enableUdiHibcc,
      enableUdiIccbba,
      ocrOrientation?.index,
      ocrLines,
      ocrMinChars,
      ocrMaxChars,
      ocrSubset,
      ocrQuietZone,
      ocrTemplate,
      ocrCheckDigitModulus,
      ocrCheckDigitMultiplier,
      ocrCheckDigitValidation,
      inverseOcr?.index,
      presentationModeSensitivity?.index,
      enableHardwareTrigger,
      autoSwitchToDefaultOnEvent?.index,
      digimarcDecoding,
      multiBarcodeCount,
      enableInstantReporting,
      reportDecodedBarcodes,
      scannerTriggerResource?.index,
      scannerInputEnabled,
      scannerSelection?.index,
      configureAllScanners,
      scannerSelectionByIdentifier,
      enableAimMode,
      beamTimer,
      enableAdaptiveScanning,
      beamWidth?.index,
      powerMode?.index,
      mpdMode?.index,
      readerMode?.index,
      linearSecurityLevel,
      picklist?.index,
      aimType?.index,
      sceneDetectQualifier?.index,
      aimTimer,
      sameBarcodeTimeout,
      triggerWakeupScan,
      differentBarcodeTimeout,
      illuminationMode?.index,
      illuminationBrightness,
      lcdMode?.index,
      lowPowerTimeout,
      delayToLowPowerMode?.index,
      inverse1dMode?.index,
      viewFinderSize,
      viewFinderPosX,
      viewFinderPosY,
      marginlessEffortLevel1d?.index,
      poorQualityBcDecodeEffortLevel?.index,
      charsetName?.index,
      autoCharsetPrefferedOrder,
      autoCharsetFallback?.index,
      viewFinderMode?.index,
      codeIdType?.index,
      volumeSliderType?.index,
      decodeAudioFeedbackUri,
      decodeHapticFeedback,
      btDisconnectOnExit,
      connectionIdleTime,
      establishConnectionTime,
      remoteScannerAudioFeedbackMode,
      remoteScannerLedFeedbackMode,
      displayBtAddressBarcode,
      goodDecodeLedTimer,
      decodingLedFeedback,
      decoderUsPlanetReportCheckDigit,
      decodeScreenNotification,
      decodeScreenTime,
      decodeScreenTranslucency,
      keepParingInfoAfterReboot,
      dpmIlluminationControl?.index,
      dpmMode?.index,
      qrLaunchEnable,
      qrLaunchEnableQrDecoder,
      qrLaunchShowConfirmationDialog,
      noDecodeTime,
    ];
  }

  static PluginBarcodeParamters decode(Object result) {
    result as List<Object?>;
    return PluginBarcodeParamters(
      decoderConfig: (result[0] as List<Object?>?)?.cast<DecoderConfigItem?>(),
      dataBarToUpcEan: result[1] as bool?,
      upcEnableMarginlessDecode: result[2] as bool?,
      upcEanSecurityLevel: result[3] as int?,
      upcEanSupplemental2: result[4] as bool?,
      upcEanSupplemental5: result[5] as bool?,
      upcEanSupplementalMode: result[6] != null
          ? UpcSupplementalMode.values[result[6]! as int]
          : null,
      upcEanRetryCount: result[7] as int?,
      upcEeanLinearDecode: result[8] as bool?,
      upcEanBookland: result[9] as bool?,
      upcEanCoupon: result[10] as bool?,
      upcEanCouponReport: result[11] != null
          ? UpcEanCouponReport.values[result[11]! as int]
          : null,
      upcEanZeroExtend: result[12] as bool?,
      upceanBooklandFormat: result[13] != null
          ? UpcEanBooklandFormat.values[result[13]! as int]
          : null,
      scanningMode: result[14] != null
          ? ScanningMode.values[result[14]! as int]
          : null,
      docCaptureTemplate: result[15] as String?,
      commonBarcodeDynamicQuantity: result[16] as int?,
      barcodeHighlightingEnabled: result[17] as bool?,
      ruleName: result[18] as String?,
      enableUdiGs1: result[19] as bool?,
      enableUdiHibcc: result[20] as bool?,
      enableUdiIccbba: result[21] as bool?,
      ocrOrientation: result[22] != null
          ? OcrOrientation.values[result[22]! as int]
          : null,
      ocrLines: result[23] as int?,
      ocrMinChars: result[24] as int?,
      ocrMaxChars: result[25] as int?,
      ocrSubset: result[26] as String?,
      ocrQuietZone: result[27] as int?,
      ocrTemplate: result[28] as String?,
      ocrCheckDigitModulus: result[29] as int?,
      ocrCheckDigitMultiplier: result[30] as int?,
      ocrCheckDigitValidation: result[31] as int?,
      inverseOcr: result[32] != null
          ? InverseOcr.values[result[32]! as int]
          : null,
      presentationModeSensitivity: result[33] != null
          ? PresentationModeSensitivity.values[result[33]! as int]
          : null,
      enableHardwareTrigger: result[34] as bool?,
      autoSwitchToDefaultOnEvent: result[35] != null
          ? SwitchOnEvent.values[result[35]! as int]
          : null,
      digimarcDecoding: result[36] as bool?,
      multiBarcodeCount: result[37] as int?,
      enableInstantReporting: result[38] as bool?,
      reportDecodedBarcodes: result[39] as bool?,
      scannerTriggerResource: result[40] != null
          ? TriggerSource.values[result[40]! as int]
          : null,
      scannerInputEnabled: result[41] as bool?,
      scannerSelection: result[42] != null
          ? ScannerIdentifer.values[result[42]! as int]
          : null,
      configureAllScanners: result[43] as bool?,
      scannerSelectionByIdentifier: result[44] as String?,
      enableAimMode: result[45] as bool?,
      beamTimer: result[46] as int?,
      enableAdaptiveScanning: result[47] as bool?,
      beamWidth: result[48] != null
          ? BeamWidth.values[result[48]! as int]
          : null,
      powerMode: result[49] != null
          ? PowerMode.values[result[49]! as int]
          : null,
      mpdMode: result[50] != null
          ? MpdMode.values[result[50]! as int]
          : null,
      readerMode: result[51] != null
          ? ReaderMode.values[result[51]! as int]
          : null,
      linearSecurityLevel: result[52] as int?,
      picklist: result[53] != null
          ? PicklistMode.values[result[53]! as int]
          : null,
      aimType: result[54] != null
          ? AimType.values[result[54]! as int]
          : null,
      sceneDetectQualifier: result[55] != null
          ? SceneDetectQualifier.values[result[55]! as int]
          : null,
      aimTimer: result[56] as int?,
      sameBarcodeTimeout: result[57] as int?,
      triggerWakeupScan: result[58] as bool?,
      differentBarcodeTimeout: result[59] as int?,
      illuminationMode: result[60] != null
          ? IlluminationMode.values[result[60]! as int]
          : null,
      illuminationBrightness: result[61] as int?,
      lcdMode: result[62] != null
          ? LcdMode.values[result[62]! as int]
          : null,
      lowPowerTimeout: result[63] as int?,
      delayToLowPowerMode: result[64] != null
          ? DelayToLowPowerMode.values[result[64]! as int]
          : null,
      inverse1dMode: result[65] != null
          ? Inverse1dMode.values[result[65]! as int]
          : null,
      viewFinderSize: result[66] as int?,
      viewFinderPosX: result[67] as int?,
      viewFinderPosY: result[68] as int?,
      marginlessEffortLevel1d: result[69] != null
          ? EffortLevel.values[result[69]! as int]
          : null,
      poorQualityBcDecodeEffortLevel: result[70] != null
          ? EffortLevel.values[result[70]! as int]
          : null,
      charsetName: result[71] != null
          ? Charset.values[result[71]! as int]
          : null,
      autoCharsetPrefferedOrder: (result[72] as List<Object?>?)?.cast<String?>(),
      autoCharsetFallback: result[73] != null
          ? Charset.values[result[73]! as int]
          : null,
      viewFinderMode: result[74] != null
          ? ViewFinderMode.values[result[74]! as int]
          : null,
      codeIdType: result[75] != null
          ? CodeIdType.values[result[75]! as int]
          : null,
      volumeSliderType: result[76] != null
          ? VolumeSliderType.values[result[76]! as int]
          : null,
      decodeAudioFeedbackUri: result[77] as String?,
      decodeHapticFeedback: result[78] as bool?,
      btDisconnectOnExit: result[79] as bool?,
      connectionIdleTime: result[80] as int?,
      establishConnectionTime: result[81] as int?,
      remoteScannerAudioFeedbackMode: result[82] as int?,
      remoteScannerLedFeedbackMode: result[83] as int?,
      displayBtAddressBarcode: result[84] as bool?,
      goodDecodeLedTimer: result[85] as int?,
      decodingLedFeedback: result[86] as bool?,
      decoderUsPlanetReportCheckDigit: result[87] as bool?,
      decodeScreenNotification: result[88] as bool?,
      decodeScreenTime: result[89] as int?,
      decodeScreenTranslucency: result[90] as int?,
      keepParingInfoAfterReboot: result[91] as bool?,
      dpmIlluminationControl: result[92] != null
          ? DpmIlluminationControl.values[result[92]! as int]
          : null,
      dpmMode: result[93] != null
          ? DpmMode.values[result[93]! as int]
          : null,
      qrLaunchEnable: result[94] as bool?,
      qrLaunchEnableQrDecoder: result[95] as bool?,
      qrLaunchShowConfirmationDialog: result[96] as bool?,
      noDecodeTime: result[97] as int?,
    );
  }
}

class ProfileConfig {
  ProfileConfig({
    required this.profileName,
    required this.configMode,
    this.barcodeParamters,
    this.intentParamters,
    required this.profileEnabled,
    this.appList,
  });

  String profileName;

  ConfigMode configMode;

  PluginBarcodeParamters? barcodeParamters;

  PluginIntentParamters? intentParamters;

  bool profileEnabled;

  List<AppEntry?>? appList;

  Object encode() {
    return <Object?>[
      profileName,
      configMode.index,
      barcodeParamters?.encode(),
      intentParamters?.encode(),
      profileEnabled,
      appList,
    ];
  }

  static ProfileConfig decode(Object result) {
    result as List<Object?>;
    return ProfileConfig(
      profileName: result[0]! as String,
      configMode: ConfigMode.values[result[1]! as int],
      barcodeParamters: result[2] != null
          ? PluginBarcodeParamters.decode(result[2]! as List<Object?>)
          : null,
      intentParamters: result[3] != null
          ? PluginIntentParamters.decode(result[3]! as List<Object?>)
          : null,
      profileEnabled: result[4]! as bool,
      appList: (result[5] as List<Object?>?)?.cast<AppEntry?>(),
    );
  }
}

class ScanEvent {
  ScanEvent({
    required this.labelType,
    required this.source,
    required this.dataString,
    required this.decodeData,
    required this.decodeMode,
  });

  LabelType labelType;

  ScanSource source;

  String dataString;

  List<Uint8List?> decodeData;

  DecodeMode decodeMode;

  Object encode() {
    return <Object?>[
      labelType.index,
      source.index,
      dataString,
      decodeData,
      decodeMode.index,
    ];
  }

  static ScanEvent decode(Object result) {
    result as List<Object?>;
    return ScanEvent(
      labelType: LabelType.values[result[0]! as int],
      source: ScanSource.values[result[1]! as int],
      dataString: result[2]! as String,
      decodeData: (result[3] as List<Object?>?)!.cast<Uint8List?>(),
      decodeMode: DecodeMode.values[result[4]! as int],
    );
  }
}

class StatusChangeEvent {
  StatusChangeEvent({
    required this.newState,
  });

  ScannerState newState;

  Object encode() {
    return <Object?>[
      newState.index,
    ];
  }

  static StatusChangeEvent decode(Object result) {
    result as List<Object?>;
    return StatusChangeEvent(
      newState: ScannerState.values[result[0]! as int],
    );
  }
}

class DecoderConfigItem {
  DecoderConfigItem({
    this.decoder,
    this.enabled,
  });

  Decoder? decoder;

  bool? enabled;

  Object encode() {
    return <Object?>[
      decoder?.index,
      enabled,
    ];
  }

  static DecoderConfigItem decode(Object result) {
    result as List<Object?>;
    return DecoderConfigItem(
      decoder: result[0] != null
          ? Decoder.values[result[0]! as int]
          : null,
      enabled: result[1] as bool?,
    );
  }
}

class _DataWedgeFlutterApiCodec extends StandardMessageCodec {
  const _DataWedgeFlutterApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ScanEvent) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StatusChangeEvent) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ScanEvent.decode(readValue(buffer)!);
      case 129: 
        return StatusChangeEvent.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class DataWedgeFlutterApi {
  static const MessageCodec<Object?> codec = _DataWedgeFlutterApiCodec();

  void onScannerStatusChanged(StatusChangeEvent statusEvent);

  void onScanResult(ScanEvent scanEvent);

  void onProfileChange();

  void onConfigUpdate();

  static void setup(DataWedgeFlutterApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScannerStatusChanged', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScannerStatusChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StatusChangeEvent? arg_statusEvent = (args[0] as StatusChangeEvent?);
          assert(arg_statusEvent != null,
              'Argument for dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScannerStatusChanged was null, expected non-null StatusChangeEvent.');
          api.onScannerStatusChanged(arg_statusEvent!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScanResult', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScanResult was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ScanEvent? arg_scanEvent = (args[0] as ScanEvent?);
          assert(arg_scanEvent != null,
              'Argument for dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onScanResult was null, expected non-null ScanEvent.');
          api.onScanResult(arg_scanEvent!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onProfileChange', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onProfileChange();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_datawedge.DataWedgeFlutterApi.onConfigUpdate', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onConfigUpdate();
          return;
        });
      }
    }
  }
}

class _DataWedgeHostApiCodec extends StandardMessageCodec {
  const _DataWedgeHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppEntry) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is DecoderConfigItem) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PluginBarcodeParamters) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PluginIntentParamters) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is ProfileConfig) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AppEntry.decode(readValue(buffer)!);
      case 129: 
        return DecoderConfigItem.decode(readValue(buffer)!);
      case 130: 
        return PluginBarcodeParamters.decode(readValue(buffer)!);
      case 131: 
        return PluginIntentParamters.decode(readValue(buffer)!);
      case 132: 
        return ProfileConfig.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class DataWedgeHostApi {
  /// Constructor for [DataWedgeHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DataWedgeHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _DataWedgeHostApiCodec();

  Future<void> createProfile(String arg_profileName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.createProfile', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_profileName]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> registerForNotifications() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.registerForNotifications', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> unregisterForNotifications() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.unregisterForNotifications', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> suspendPlugin() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.suspendPlugin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> resumePlugin() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.resumePlugin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> enablePlugin() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.enablePlugin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> disablePlugin() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.disablePlugin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> softScanTrigger(bool arg_on) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.softScanTrigger', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_on]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<String> getPackageIdentifer() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.getPackageIdentifer', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<void> setDecoder(Decoder arg_decoder, bool arg_enabled, String arg_profileName) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.setDecoder', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_decoder.index, arg_enabled, arg_profileName]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setProfileConfig(ProfileConfig arg_config) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.flutter_datawedge.DataWedgeHostApi.setProfileConfig', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_config]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}
